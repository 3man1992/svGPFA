
import pdb
import torch
from abc import ABC, abstractmethod
from utils import pinv3D

class KernelMatricesStore(ABC):

    def setKernels(self, kernels):
        self._kernels = kernels

class IndPointsKMS(KernelMatricesStore):
    def buildKernelsMatrices(self, Z):
        self.__Z = Z
        self.__buildZKernelMatrices(Z=Z)

    def getKzz(self):
        return self._Kzz

    def getKzzi(self):
        return self._Kzzi

    def getIndPointLocs(self):
        return self.__Z

    def getKernelseParams(self):
        answer = []
        for i in range(len(self.__kernels)):
            answer.append(self.__kernels[i].getVariableParameters())
        return answer

    def __buildZKernelMatrices(self, Z, epsilon=1e-5):
        nLatent = len(kernels)
        self._Kzz = [[None] for k in range(nLatent)]
        self._Kzzi = [[None] for k in range(nLatent)]

        for k in range(nLatent):
            self._Kzz[k] = self._kernels[k].buildKernelsMatrix(X1=Z[k])+epsilon*torch.eye(n=Z[k].shape[1], dtype=torch.double)
            self._Kzzi[k] = pinv3D(self._Kzz[k])

class IndPointsLocsAndTimesKMS(KernelMatricesStore):
    @abstractmethod
    def getKtz():
        pass

    @abstractmethod
    def getKtt():
        pass

class IndPointsAndAllTimesKMS(IndPointsLocsAndTimesKMS):

    def buildKernelsMatrices(self, Z, t):
        # t \in nTrials x nQuad x 1
        nLatent = len(Z)
        self._Ktz = [[None] for k in range(nLatent)]
        self._Ktt = torch.zeros(t.shape[0], t.shape[1], nLatent, 
                                dtype=torch.double)
        for k in range(nLatent):
            self._Ktz[k] = self._kernels[k].buildKernelsMatrix(X1=t, X2=Z[k])
            self._Ktt[:,:,k] = self._kernels[k].buildKernelsMatrixDiag(X=t).squeeze()

    def getKtz(self):
        return self._Ktz

    def getKtt(self):
        return self._Ktt

class IndPointsAndAssocTimesKMS(IndPointsLocsAndTimesKMS):

    def buildKernelsMatrices(self, Z, Y):
        # Y[tr] \in nSpikes of all neurons in trial tr
        nLatent = len(Z)
        nTrial = Z[0].shape[0]
        self._Ktz_allNeuronsAssocTimes = [[[None] for tr in range(nTrial)] for k in range(nLatent)]
        self._Ktt_allNeuronsAssocTimes = [[[None] for tr in  range(nTrial)] for k in range(nLatent)]

        for k in range(nLatent):
            for tr in range(nTrial):
                self._Ktz[k][tr] = self._kernels[k].buildKernelsMatrix(X1=Y[tr], X2=Z[k][tr,:,:])
                self._Ktt[k][tr] = self._kernels[k].buildKernelsMatrixDiag(X=Y[tr])
    def getKtz(self):
        return self._Ktz

    def getKtt(self):
        return self._Ktt

